---
layout: post
title: åŠ å¯†ä¼ è¾“Demo V2
tags: [åŠ å¯†, Demo]
--- 
  å¤ªä¸šä½™æ€»æ„Ÿè§‰ä¸å¤ªå¥½å•Š<!--more-->    

# å‰è¨€
  åœ¨ä¸Šä¸ªæœˆæˆ‘å†™äº†ä¸€ä¸ª[åŠ å¯†ä¼ è¾“çš„Demo](/2020/05/29/encrypt.html)ï¼Œç›¸å½“çš„ä¸šä½™ï¼Œè¿™ä¸ªä¸œè¥¿åªèƒ½åšåˆ°ä»å®¢æˆ·ç«¯å‘æœåŠ¡ç«¯çš„å•å‘ä¼ è¾“ï¼Œè€Œä¸”å› ä¸ºåªæœ‰ä¸€æ¬¡è¯·æ±‚ï¼Œæ‰€ä»¥ä¸­é—´äººæ”»å‡»ä¹Ÿéå¸¸çš„å®¹æ˜“ã€‚   
  è™½ç„¶æˆ‘è§‰å¾—é‚£ä¸ªåº”è¯¥è¶³å¤Ÿæˆ‘å®Œæˆä½œä¸šäº†ï¼Œä½†æ˜¯æˆ‘æƒ³äº†æƒ³ï¼Œå¤ªä¸šä½™æ€»æ˜¾å¾—æˆ‘å¾ˆèœ ~~ï¼ˆéš¾é“ä¸æ˜¯å—ï¼Ÿï¼‰~~ ï¼Œæ‰€ä»¥æˆ‘æ‰“ç®—è¿˜æ˜¯åŠªåŠ›ä¸€ä¸‹æŠŠå®Œæ•´çš„æ¡æ‰‹ä¹Ÿåšå‡ºæ¥å§ã€‚   

# å®ç°æ€è·¯
  å’Œä¸Šæ¬¡å·®ä¸å¤šï¼ŒåŒæ ·æˆ‘æ‰“ç®—é€šè¿‡RSAåŠ å¯†ä¸€ä¸ªéšæœºæ•°ä½œä¸ºAESçš„å¯†é’¥ï¼Œä½†æ˜¯å’Œä¸Šæ¬¡ä¸åŒï¼Œè¿™æ¬¡çš„è¿™ä¸ªå¯†é’¥å°†åœ¨é€šä¿¡å»ºç«‹ä¹‹åå¯†é’¥å°±ä¸å†å˜åŒ–ï¼Œä¼ å…¥ä¼ å‡ºéƒ½æ˜¯è¿™ä¸ªå¯†é’¥ã€‚   
  ä¹‹å‰è§‰å¾—æ¡æ‰‹é˜¶æ®µå¯èƒ½å¾ˆéº»çƒ¦ï¼Œä¸è¿‡æˆ‘ç”»äº†ä¸€ä¸‹å›¾ç¨å¾®ç†äº†ç†æ€è·¯å‘ç°å…¶å®ä¹Ÿæ²¡å¤šå¤æ‚ï¼Œä¹Ÿå°±æ˜¯å®¢æˆ·ç«¯ç”Ÿæˆå¯†é’¥ç„¶ååŠ å¯†ä¼ è¾“è¿‡æ¥è®©æœåŠ¡ç«¯ä¿å­˜ï¼Œå®Œæˆä¹‹åä¹‹é—´çš„ä¼ è¾“åªè¦ä¼ è¢«åŠ å¯†çš„æ•°æ®å°±è¡Œäº†ã€‚è¿™æ ·æˆ‘è§‰å¾—åº”è¯¥ä¹Ÿèƒ½èµ·åˆ°ä¸€å®šçš„é˜²æ­¢ä¸­é—´äººæ”»å‡»çš„ä½œç”¨å§â€¦â€¦     
  ä¸è¿‡æˆ‘åªç”¨äº†ä¸€ä¸ªæ–‡ä»¶ä½œä¸ºä¼ è¾“çš„ç®¡é“ï¼Œä¸ºäº†é¿å…å†²çªï¼Œæˆ‘åœ¨æ¯æ¬¡å†™å…¥æ•°æ®çš„æ—¶å€™ä¹Ÿéƒ½æ ‡æ˜äº†æ•°æ®çš„æ¥æºï¼Œè¿™æ ·å°±ä¸ä¼šå› ä¸ºè‡ªå·±åˆšå‘å®Œç„¶åè‡ªå·±åˆé‡æ–°æ¥æ”¶è‡ªå·±å‘çš„ä¸œè¥¿äº†ã€‚   
  å¦å¤–è€å¸ˆå¸Œæœ›æˆ‘çš„Demoæœ‰ä¸ªç®€å•çš„åº”ç”¨ï¼Œæ‰€ä»¥æˆ‘åˆå¦å¤–åŠ äº†ä¸€ä¸ªæå…¶ç®€å•çš„ç™»å½•ç³»ç»Ÿåœ¨é‡Œé¢ï¼Œè¿™æ ·æˆ‘å°±ä¸ç”¨æ‰‹åŠ¨æ“ä½œæœåŠ¡ç«¯äº†ã€‚
  
# ä»£ç 
## server.py
```python
# -*- coding: utf-8 -*-
print("åŠ å¯†é€šé“æœåŠ¡ç«¯æ¼”ç¤ºå¼€å§‹")
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Cipher import AES  
import base64
import hashlib
import json
import time

private_key = """-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDfEQ82qUrto7h4BL3TsA/DFXSdM44cbeY4kPccD7gLGhaZRClz
YKIh5zYdfjBGF+0HXfMa1u9b7GNs2AjVIsx8Kx0QLnMfmtkmGWGhOXz/9IDLKJOx
0weKv61gysKItgzVKn2mbLool4R/PQBc3AjDyHw+io1KpVz+3kRTaGs1fQIDAQAB
AoGAWB4kFWLA/6k6OOcemd4mC9mQ7HyuOdrMJDJX+5TWDkSrArajbTmSMrRkczgj
F71h3BQn8cVQXs695ARfUNrjTbi2Y0LjN7ScK7ExzTLdoMEFw5JsHggJZ0zBQY6w
mwOdGfqzA6tZPXgkn+jqEha+CD6GrwnTM1oDGJC/aKG2OmECQQDkO9IhUhFc/PSU
0zvGE6AOcqk5wlOuvMg+oAFHJHJZ9XW7+X/Nx0ZoVDFq/cZQj+46t+fiwUwhdW7l
IfCvNGKFAkEA+jRQmWGKrbf1ns4S0SezJvysd5O6otRGJXr+Ex2uDhc39ZTeUsyg
kjrLhp8STLMOmql+8g5fghct17EuCX1EmQJBAJz9BNnEkIrst/OSpH/nyeWGOx6u
q077LaXd+2MLD9kO/O/Se3V5B9YFa4STkJCjoBMloswXd51gIGpdgSeSmd0CQQCL
PrwwcGmWfo+ynqs4PajlpK9zKQMwhYS4bTejedwZOXDKOtx0Ji+i0hfcxwCPMQOK
rZPZsIgUxUOdC508aLvZAkBDkHxunCzDm0w4DdTUN7S9YSpVvQEjK/xUQiWaKV12
8QgskhU2DNdYK2NxifnWrKtx3uQmqMxX5aLuJZ4493yr
-----END RSA PRIVATE KEY-----"""

# å…¬é’¥è§£å¯†
def rsa_decode(cipher_text, private_key):
    rsakey = RSA.importKey(private_key)  # å¯¼å…¥è¯»å–åˆ°çš„ç§é’¥
    cipher = PKCS1_v1_5.new(rsakey)  # ç”Ÿæˆå¯¹è±¡
    # å°†å¯†æ–‡è§£å¯†æˆæ˜æ–‡ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªbytesç±»å‹æ•°æ®ï¼Œéœ€è¦è‡ªå·±è½¬æ¢æˆstr
    text = cipher.decrypt(base64.b64decode(cipher_text), "ERROR")
    return text.decode()
    
class PrpCrypt(object):
 
    def __init__(self, key):
        self.key = key.encode('utf-8')
        self.mode = AES.MODE_CBC
        
    def encrypt(self, text):
        text = text.encode('utf-8')
        cryptor = AES.new(self.key, self.mode, b'0000000000000000')
        # è¿™é‡Œå¯†é’¥key é•¿åº¦å¿…é¡»ä¸º16ï¼ˆAES-128ï¼‰,
        # 24ï¼ˆAES-192ï¼‰,æˆ–è€…32 ï¼ˆAES-256ï¼‰Bytes é•¿åº¦
        # ç›®å‰AES-128 è¶³å¤Ÿç›®å‰ä½¿ç”¨
        length = 16
        count = len(text)
        if count < length:
            add = (length - count)
            # \0 backspace
            # text = text + ('\0' * add)
            text = text + ('\0' * add).encode('utf-8')
        elif count > length:
            add = (length - (count % length))
            # text = text + ('\0' * add)
            text = text + ('\0' * add).encode('utf-8')
        self.ciphertext = cryptor.encrypt(text)
        # å› ä¸ºAESåŠ å¯†æ—¶å€™å¾—åˆ°çš„å­—ç¬¦ä¸²ä¸ä¸€å®šæ˜¯asciiå­—ç¬¦é›†çš„ï¼Œè¾“å‡ºåˆ°ç»ˆç«¯æˆ–è€…ä¿å­˜æ—¶å€™å¯èƒ½å­˜åœ¨é—®é¢˜
        # æ‰€ä»¥è¿™é‡Œç»Ÿä¸€æŠŠåŠ å¯†åçš„å­—ç¬¦ä¸²è½¬åŒ–ä¸º16è¿›åˆ¶å­—ç¬¦ä¸²
        return base64.b64encode(self.ciphertext)
 
    # è§£å¯†åï¼Œå»æ‰è¡¥è¶³çš„ç©ºæ ¼ç”¨strip() å»æ‰
    def decrypt(self, text):
        cryptor = AES.new(self.key, self.mode, b'0000000000000000')
        plain_text = cryptor.decrypt(base64.b64decode(text))
        # return plain_text.rstrip('\0')
        return bytes.decode(plain_text).rstrip('\0')

#åˆå§‹åŒ–pipe
file = open('pipe.txt','w')
print("",file = file)
file.close()
#åå•†å¯†é’¥
while True:
    pipe = open("pipe.txt", mode='r')
    data = pipe.read()
    if not data == "\n":
        data = json.loads(data)
        pipe.close()
        break
    pipe.close()
    time.sleep(1)
file = open('pipe.txt','w')
print("",file = file)
file.close()
key = rsa_decode(data["key"], private_key)
akey = PrpCrypt(key)
print("æˆåŠŸè·å–å¯†é’¥",key)
print("å·²å»ºç«‹è¿æ¥")
userInfo={"Name":"Mayx","Passwd":'25d55ad283aa400af464c76d713c07ad',"Book":"ã€Šä¼šè¯´è¯å°±å¤šè¯´ç‚¹ã€‹ï¼Œã€Šåœ¨å“ªé‡Œèƒ½ä¹°åˆ°æ‚¨çš„è‘—ä½œã€‹"}

#å¤„ç†é˜¶æ®µ
#Waiting for Quest
while True:
    pipe = open("pipe.txt", mode='r')
    data = pipe.read()
    if not data == "\n":
        data = json.loads(data)
        if data["from"] == "Client":
            pipe.close()
            break
    pipe.close()
    time.sleep(1)
print("å·²æ”¶åˆ°è¯·æ±‚")
data = json.loads(akey.decrypt(data["data"]))
if data["name"] == userInfo["Name"] and data["pwd"] == userInfo["Passwd"]:
    file = open('pipe.txt','w')
    print(json.dumps({"from":"Server","data":akey.encrypt("ç™»å½•æˆåŠŸï¼Œæ‚¨çš„ä¹¦å•å¦‚ä¸‹ï¼š"+userInfo["Book"]).decode("utf-8")}),file = file)
    file.close()
else:
    file = open('pipe.txt','w')
    print(json.dumps({"from":"Server","data":akey.encrypt("ç™»å½•å¤±è´¥").decode("utf-8")}),file = file)
    file.close()
print("è¯·æ±‚å·²å›åº”")
print("åŠ å¯†é€šé“æœåŠ¡ç«¯æ¼”ç¤ºç»“æŸ")
```

## client.py
```python
# -*- coding: utf-8 -*-
print("åŠ å¯†é€šé“å®¢æˆ·ç«¯æ¼”ç¤ºå¼€å§‹")
import random
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Cipher import AES  
import base64
import hashlib
import json
import time

public_key = """-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDfEQ82qUrto7h4BL3TsA/DFXSd
M44cbeY4kPccD7gLGhaZRClzYKIh5zYdfjBGF+0HXfMa1u9b7GNs2AjVIsx8Kx0Q
LnMfmtkmGWGhOXz/9IDLKJOx0weKv61gysKItgzVKn2mbLool4R/PQBc3AjDyHw+
io1KpVz+3kRTaGs1fQIDAQAB
-----END PUBLIC KEY-----
"""

# å…¬é’¥åŠ å¯†
def rsa_encode(message, public_key):
    rsakey = RSA.importKey(public_key)  # å¯¼å…¥è¯»å–åˆ°çš„å…¬é’¥
    cipher = PKCS1_v1_5.new(rsakey)  # ç”Ÿæˆå¯¹è±¡
    # é€šè¿‡ç”Ÿæˆçš„å¯¹è±¡åŠ å¯†messageæ˜æ–‡ï¼Œæ³¨æ„ï¼Œåœ¨python3ä¸­åŠ å¯†çš„æ•°æ®å¿…é¡»æ˜¯bytesç±»å‹çš„æ•°æ®ï¼Œä¸èƒ½æ˜¯strç±»å‹çš„æ•°æ®
    cipher_text = base64.b64encode(cipher.encrypt(message.encode(encoding="utf-8")))
    # å…¬é’¥æ¯æ¬¡åŠ å¯†çš„ç»“æœä¸ä¸€æ ·è·Ÿå¯¹æ•°æ®çš„paddingï¼ˆå¡«å……ï¼‰æœ‰å…³
    return cipher_text.decode()

class PrpCrypt(object):
 
    def __init__(self, key):
        self.key = key.encode('utf-8')
        self.mode = AES.MODE_CBC
 
    # åŠ å¯†å‡½æ•°ï¼Œå¦‚æœtextä¸è¶³16ä½å°±ç”¨ç©ºæ ¼è¡¥è¶³ä¸º16ä½ï¼Œ
    # å¦‚æœå¤§äº16å½“æ—¶ä¸æ˜¯16çš„å€æ•°ï¼Œé‚£å°±è¡¥è¶³ä¸º16çš„å€æ•°ã€‚
    def encrypt(self, text):
        text = text.encode('utf-8')
        cryptor = AES.new(self.key, self.mode, b'0000000000000000')
        # è¿™é‡Œå¯†é’¥key é•¿åº¦å¿…é¡»ä¸º16ï¼ˆAES-128ï¼‰,
        # 24ï¼ˆAES-192ï¼‰,æˆ–è€…32 ï¼ˆAES-256ï¼‰Bytes é•¿åº¦
        # ç›®å‰AES-128 è¶³å¤Ÿç›®å‰ä½¿ç”¨
        length = 16
        count = len(text)
        if count < length:
            add = (length - count)
            # \0 backspace
            # text = text + ('\0' * add)
            text = text + ('\0' * add).encode('utf-8')
        elif count > length:
            add = (length - (count % length))
            # text = text + ('\0' * add)
            text = text + ('\0' * add).encode('utf-8')
        self.ciphertext = cryptor.encrypt(text)
        # å› ä¸ºAESåŠ å¯†æ—¶å€™å¾—åˆ°çš„å­—ç¬¦ä¸²ä¸ä¸€å®šæ˜¯asciiå­—ç¬¦é›†çš„ï¼Œè¾“å‡ºåˆ°ç»ˆç«¯æˆ–è€…ä¿å­˜æ—¶å€™å¯èƒ½å­˜åœ¨é—®é¢˜
        # æ‰€ä»¥è¿™é‡Œç»Ÿä¸€æŠŠåŠ å¯†åçš„å­—ç¬¦ä¸²è½¬åŒ–ä¸º16è¿›åˆ¶å­—ç¬¦ä¸²
        return base64.b64encode(self.ciphertext)
        
        # è§£å¯†åï¼Œå»æ‰è¡¥è¶³çš„ç©ºæ ¼ç”¨strip() å»æ‰
    def decrypt(self, text):
        cryptor = AES.new(self.key, self.mode, b'0000000000000000')
        plain_text = cryptor.decrypt(base64.b64decode(text))
        # return plain_text.rstrip('\0')
        return bytes.decode(plain_text).rstrip('\0')

#åˆå§‹åŒ–é˜¶æ®µ
while True:
    try:
        pipe = open("pipe.txt", mode='r')
    except:
        time.sleep(1)
    else:
        break
pipe.close()
#åå•†å¯†é’¥
key = str(random.randint(1000000000000000,9999999999999999))
akey = PrpCrypt(key)
cipher = rsa_encode(key, public_key)
data = json.dumps({"key":cipher})
file = open('pipe.txt','w')
print(data,file = file)
file.close()
while True:
    pipe = open("pipe.txt", mode='r')
    if pipe.read() == "\n":
        pipe.close()
        break
    pipe.close()
    time.sleep(1)
print("æˆåŠŸå‘é€å¯†é’¥",key)
print("å·²å»ºç«‹è¿æ¥")

#å¤„ç†é˜¶æ®µ
#Single Quest
name = input("è¯·è¾“å…¥ç”¨æˆ·åï¼š")
pwd = input("è¯·è¾“å…¥å¯†ç ï¼š")
hash = hashlib.md5(pwd.encode(encoding='UTF-8')).hexdigest()
data = json.dumps({"from":"Client","data":akey.encrypt(json.dumps({"name":name,"pwd":hash})).decode("utf-8")})
file = open('pipe.txt','w')
print(data,file = file)
file.close()
print("å·²å‘å‡ºï¼Œç­‰å¾…å›åº”")
while True:
    pipe = open("pipe.txt", mode='r')
    data = pipe.read()
    if not data == "\n":
        data = json.loads(data)
        if data["from"] == "Server":
            pipe.close()
            break
    pipe.close()
    time.sleep(1)
print("å·²æ”¶åˆ°å›åº”")
data = akey.decrypt(data["data"])
print(data)
print("åŠ å¯†é€šé“å®¢æˆ·ç«¯æ¼”ç¤ºç»“æŸ")
```

# åè®°
  å…³äºSSL/TLSçš„å…·ä½“å†…å®¹æˆ‘ä¹Ÿæ²¡æœ‰å¥½å¥½çœ‹ä¸€éï¼Œæˆ‘æ‰“ç®—å›å¤´æœ‰æ—¶é—´ä»”ç»†çœ‹ä¸€çœ‹ï¼Œç„¶åå†å›æ¥çœ‹è¿™ä¸ªä»£ç æ˜¯æœ‰å¤šä¹ˆçš„ç³Ÿç³•ğŸ¤ªã€‚
