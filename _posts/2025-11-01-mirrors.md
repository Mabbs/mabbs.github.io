---
layout: post
title: 让博客永恒的探索
tags: [Git, Gitea, 镜像, Forever]
---

  Mayx Forever Project – Phase II<!--more-->   

# 起因
  在前段时间，我通过[Ecosyste.ms: Repos](https://github.com/ecosyste-ms/repos)找到了不少Git平台的实例，也在探索的过程中发现和了解了[Tilde社区](/2025/08/10/tilde.html)。当然仅仅是这样显然还不够，里面的实例太多了，显然还有一些其他值得探索的东西。   
  在我查看这里面的某些Gitea实例时，发现了一些奇怪的事情，有些实例的仓库数和用户数多得离谱，正常来说除了几个大的平台，绝大多数应该只有几十到几百个仓库，这就让我有点好奇了。于是当我点进去之后发现，里面有一大堆仓库都是空的，而且用户名和仓库名都非常有规律，看起来都是一组单词加4位数字命名的，显然这不是正常现象，应该是一种有组织的行为。   

# 被SPAM滥用的Git实例
  于是我就简单看了一下这些异常的仓库和用户的规律，可以发现每个用户都填了个人主页地址，然后个人简介里大都是一段广告词。另外这些个人主页的地址看起来很多都是利用公开可注册的服务，比如开源的有各种Git平台、Wiki，以及论坛，还有一些允许用户写个人主页的新闻网站。在这其中，Git平台大多都没有广告文章，基本上都是通过个人主页地址链接到网站，而Wiki之类的就会写一些篇幅比较长的广告文章。   
  另外这些平台但凡还在开放注册，就会被以大约每分钟一次的速度自动注册新账号……所以这种事情到底是谁在干呢？我翻了几个仓库，里面的广告多种多样，有些看起来还算正常，还有一些看起来有些黑产。其中我发现有一家叫做“悠闲羊驼SEO”的网站，看介绍主要是给加密货币、对冲基金和博彩网站提供SEO优化的，再加上这些被滥用的平台里也有不少类似的广告，所以我怀疑这些滥用的行为就是这家SEO公司做的（虽然没有证据😂）。   

# 永恒的探索
  看到这么多Git平台被滥用，我就有个想法，之前为了保证可靠性给博客加了不少[镜像](/proxylist.html)，除此之外也在互联网档案馆、[Software Heritage](https://archive.softwareheritage.org/)、Git Protect等存档服务中上传了备份，而且也在IPFS和Arweave等Web3平台上有相应的副本，但是我觉得还不够，再大的平台也有可能会倒闭，IPFS不Pin还会被GC，至于Arweave前段时间看了一眼整个网络才几百个节点，感觉一点也不靠谱……所以我应该好好利用这些平台提高我博客的可靠性。   
  既然那些Spammer只是为了SEO去滥用这些平台，不如让我利用这些平台给我的博客进行镜像吧！至于使用哪个平台……显然用Git平台方便一些，所以接下来就该考虑一下怎么样分发了。   

# 镜像的分发
  在Git平台中也有很多选择，最知名的是GitLab，不过GitLab有点复杂，接口不太好用……而且很多实例没有开镜像仓库的功能，毕竟如果我每次更新都给一堆仓库推送太费时间了，我打算让各个平台主动从GitHub上拉取我的最新代码。正好Gogs系列的平台基本上都默认支持镜像仓库，不过在我实际使用的时候发现Gogs默认情况下注册要验证码……写识别验证码感觉又挺麻烦，而Gogs的两个分支——Gitea和Forgejo反倒没有……还挺奇怪，所以接下来我的目标主要就是Gitea和Forgejo的实例了。   
  既然决定好目标，我就得先发现它们了，那些Spammer在注册的时候会在个人主页里写不同的网站，其中也有一些类Gogs平台，那么我可以先找一个Gitea平台，用接口读取这些网站，然后再调类Gogs专属的接口来检测这些网站哪个是类Gogs平台，于是我就写了个[脚本](https://github.com/Mabbs/spam_gogs-like_scanner/blob/main/main.py)来找到它们。   
  找到这些平台之后就该注册了，还好Gitea和Forgejo默认没有验证码，注册起来也很简单，随便写了个函数实现了一下：   
```python
def register_account(session, url, email, username, password):
    try:
        resp = session.get(url + "/user/sign_up")
        soup = BeautifulSoup(resp.text, "html.parser")
        csrf_token = soup.find("input", {"name": "_csrf"}).get("value")

        payload = {
            "_csrf": csrf_token,
            "user_name": username,
            "email": email,
            "password": password,
            "retype": password,
        }
        headers = {"Content-Type": "application/x-www-form-urlencoded"}
        resp = session.post(url + "/user/sign_up", data=payload, headers=headers)
        if "flash-success" in resp.text:
            print(
                f"Successfully registered at {url} with username: {username}, email: {email}, password: {password}"
            )
            save_to_file(
                "instances_userinfo.csv", f"{url},{username},{email},{password}"
            )
            return True
        else:
            print(f"Failed to register at {url}.")
            return False
    except Exception as e:
        print(f"Error registering at {url}: {e}")
        return False
```
  注册完之后就该导入仓库了，只是通过模拟前端发包的方式在Gitea和Forgejo中不同版本的表现可能不太一样，所以我想用API实现，但是API又得有API Key，生成API Key还得模拟前端发包😥……所以怎么都绕不过。   
  不过这个生成API Key还挺麻烦，有些版本不需要配权限范围，有些配权限的参数还不一样……不过我就是随便一写，凑合用吧，像那些专业的Spammer应该是有更强大的脚本判断各种情况。   
  最后我还是选择用API导入，又写了个函数：   
```python
def import_repos(token, url):
    try:
        response = requests.post(
            url=url + "/api/v1/repos/migrate",
            headers={
                "Authorization": "token " + token,
            },
            json={
                "repo_name": "blog",
                "mirror_interval": "1h",
                "mirror": True,
                "description": "Mayx's Home Page",
                "clone_addr": "https://github.com/Mabbs/mabbs.github.io",
            },
        )
        if response.status_code == 201:
            print("Repository import initiated successfully.")
            save_to_file("repo_list.txt", url + "/mayx/blog")
            return True
        else:
            print(f"Failed to initiate repository import. Status code: {response.status_code}")
            print(f"Response: {response.text}")
            return False
    except Exception as e:
        print(f"Error updating website: {e}")
        return False
```
  脚本写好之后我就只需要重复扫描、注册、导入的步骤就行了，这样我的镜像就会越来越多，而且用类Gogs的实例还有一个好处就是不需要我手动推送，它会自动定时拉取我的仓库保持最新，这样也许只要人类文明存在我的博客就会在某处存在吧🤣。   
  最后我创建的Git镜像可以在[这里](/other_repo_list.html)看到，看起来还是挺壮观啊😋。只不过像这种会被Spammer随便注册的Git平台实例很难说它能活多久，如果没人管而且是云服务器也许到期就没了，有人管的话应该不会允许这么多Spam行为吧……   

# 感想
  不知道用“量”来确保博客的永恒更可靠……还是用“质”的方式更好呢？其实我觉得还得是活动的更好，就像我以前所说的，如果有[僵尸网络](/2024/11/02/trojan.html#%E6%84%9F%E6%83%B3)，自动帮我执行发现并推送的操作，也许比等着这些实例逐渐消失更好吧……只不过那样可能就不太友好了😂。